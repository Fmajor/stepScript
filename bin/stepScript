#!python3
import sys
import getopt
import re
import os
opts, args = getopt.getopt(sys.argv[1:], "ihc:", ["help", "config=", "prepare", "show"])
def help():
  helpStr = '''stepScript [-ic] [--help --prepare] [scriptToProcess]
    -i:         go into debug mode
    -c file:    use file as config file
    -h, --help: print this help string
    --prepare:  generate makefile to play with'''
  print(helpStr)
  sys.exit(1)
if len(args) > 1:
  raise Exception('can only process one script, have {}'.format(args))

# to reduce the dependency, copy the source code from colorama
# begin from colorama/ansi.py
CSI = '\033['
OSC = '\033]'
BEL = '\007'
def code_to_chars(code):
    return CSI + str(code) + 'm'
class AnsiCodes(object):
    def __init__(self):
        # the subclasses declare class attributes which are numbers.
        # Upon instantiation we define instance attributes, which are the same
        # as the class attributes but wrapped with the ANSI escape sequence
        for name in dir(self):
            if not name.startswith('_'):
                value = getattr(self, name)
                setattr(self, name, code_to_chars(value))
class AnsiFore(AnsiCodes):
    BLACK           = 30
    RED             = 31
    GREEN           = 32
    YELLOW          = 33
    BLUE            = 34
    MAGENTA         = 35
    CYAN            = 36
    WHITE           = 37
    RESET           = 39

    # These are fairly well supported, but not part of the standard.
    LIGHTBLACK_EX   = 90
    LIGHTRED_EX     = 91
    LIGHTGREEN_EX   = 92
    LIGHTYELLOW_EX  = 93
    LIGHTBLUE_EX    = 94
    LIGHTMAGENTA_EX = 95
    LIGHTCYAN_EX    = 96
    LIGHTWHITE_EX   = 97
class AnsiBack(AnsiCodes):
    BLACK           = 40
    RED             = 41
    GREEN           = 42
    YELLOW          = 43
    BLUE            = 44
    MAGENTA         = 45
    CYAN            = 46
    WHITE           = 47
    RESET           = 49

    # These are fairly well supported, but not part of the standard.
    LIGHTBLACK_EX   = 100
    LIGHTRED_EX     = 101
    LIGHTGREEN_EX   = 102
    LIGHTYELLOW_EX  = 103
    LIGHTBLUE_EX    = 104
    LIGHTMAGENTA_EX = 105
    LIGHTCYAN_EX    = 106
    LIGHTWHITE_EX   = 107
class AnsiStyle(AnsiCodes):
    BRIGHT    = 1
    DIM       = 2
    NORMAL    = 22
    RESET_ALL = 0
Fore   = AnsiFore()
Back   = AnsiBack()
Style  = AnsiStyle()
# end of colorama

blankExtractor = re.compile(r"^(\t+).*")
def getLevel(input):
  result = blankExtractor.findall(input)
  if len(result) == 0:
    return [0, input[:-1]]
  elif len(result) == 1:
    blank = result[0]
    level = len(blank)
    return [level, input[level:-1]]
  else:
    raise Exception('need debug here for {}'.format(input))
makefileTemplate='''.PHONY: update step showStruct showAll edit all run showCommand
RAWSCRIPT :=
SCRIPT := .$(RAWSCRIPT).step.sh
FLAGS :=

all: run
show:
ifeq ($(RAWSCRIPT),)
	$(error the name of the raw script is empty, edit it...)
endif
	stepScript --show $(RAWSCRIPT)

help:
	@echo "update step showStruct showAll edit"

step: run
	@:
showStruct: run
	@:
showCommand: run
	@:
showAll: run
	@:
update: run
	@:
edit:
	vim ./.stepScript.session

doProcess :=
ifneq ($(SCRIPT), $(wildcard $(SCRIPT)))
	doProcess:=True
endif
ifneq ($(findstring update,$(MAKECMDGOALS)),)
	doProcess:=True
endif
run:
ifeq ($(RAWSCRIPT),)
	$(error the name of the raw script is empty, edit it...)
endif
ifneq ($(doProcess),)
	stepScript $(RAWSCRIPT)
endif
ifneq ($(findstring step,$(MAKECMDGOALS)),)
	$(eval FLAGS:=$(FLAGS) -s)
endif
ifneq ($(findstring showStruct,$(MAKECMDGOALS)),)
	$(eval FLAGS:=$(FLAGS) -S)
endif
ifneq ($(findstring showCommand,$(MAKECMDGOALS)),)
	$(eval FLAGS:=$(FLAGS) -A)
endif
ifneq ($(findstring showAll,$(MAKECMDGOALS)),)
	$(eval FLAGS:=$(FLAGS) -SA)
endif
	bash $(SCRIPT) $(FLAGS)
clean:
	rm .stepScript.session
	rm $(SCRIPT)
'''
def doPrepare():
  mode = 'w'
  if os.path.exists('./makefile'):
    print('make file already exists, Enter twice to add to the tail, Ctrl+C to exit', end="")
    _ = input()
    _ = input()
    mode = 'a'
  with open('makefile', mode) as f:
    f.write(makefileTemplate)
  sys.exit(0)
# default config
config = {
  'structPrefix': '## ',
  'skipPrefix': '#x ',
  'normalPrefix': '# ',
}
commentStyle = f'{Fore.BLUE}{{}}{Style.BRIGHT}{Style.RESET_ALL}'
commandStyle = f'{Fore.YELLOW}{{}}{Style.BRIGHT}{Style.RESET_ALL}'
levelColor = [
  f'{Fore.LIGHTGREEN_EX}{{}}{Style.NORMAL}{Style.RESET_ALL}',
  f'{Fore.GREEN}{{}}{Style.NORMAL}{Style.RESET_ALL}',
  f'{Fore.GREEN}{{}}{Style.BRIGHT}{Style.RESET_ALL}',
]
configFile = ''
onlyShow = False
for op, value in opts:
  if op in ['-h', '--help']:
    help()
  elif op in ['-c', '--config']:
    configFile = value
  elif op in ['--prepare']:
    doPrepare()
  elif op in ['--show']:
    onlyShow = True
if len(args) == 0:
  help()
inputFile = args[0]

if configFile:
  import yaml
  with open(configFile) as f:
    _config = yaml.load(f)
  config.update(_config)
debug = False
for op, value in opts:
  if op in ['--indentDelimiter']:
    config['indentDelimiter'] = value
  elif op == '-i':
    debug = True
struct = {
  'title': '',
  'level': -1,
  'commands': [],
  "type": "struct",
  'line': 0,
}
# basic struct
stack = [struct]
currentStruct = struct
currentCommands = []
f = open(inputFile)

multilineState = False
multilineList = []
newGroup = True
newCommand = None
# main loop for parse
for lineNumber, eachline in enumerate(f, start=1):
  [thisLevel, eachline] = getLevel(eachline)
  if not eachline.strip(): continue
  #print('{:2d} {} {}'.format(thisLevel, thisLevel * '  ', eachline))
  structLevel = currentStruct['level']
  if thisLevel > structLevel: # normal state
    pass
  elif thisLevel <= structLevel: # goto last level
    dlevel = structLevel - thisLevel + 1
    #print('level -= {} with {}'.format(dlevel, eachline))
    while dlevel:
      currentStruct = stack.pop()
      currentCommands = currentStruct['commands']
      structLevel = currentStruct['level']
      dlevel -= 1
  if not newCommand:
    newCommand = {
      'comments': [],
      'level': thisLevel,
      'type': 'group',
      'command': None,
    }
  if eachline.startswith('#!'): continue
  elif eachline.startswith('set -e'): continue
  elif eachline.startswith('#'): # this is a comment
    if multilineState and not eachline.startswith('#mle'):
      raise Exception('line {}: should not have comment in multiline state'.format(lineNumber))
    if eachline.startswith('## '): # new struct, new level
      newCommand = None
      thisTitle = eachline[3:]
      stack.append(currentStruct)
      currentStruct = {
        "title": thisTitle,
        "level": thisLevel,
        "commands": [],
        "type": "struct",
        "line": lineNumber,
      }
      currentCommands = currentStruct['commands']
      stack[-1]['commands'].append(currentStruct)
      #print('level ++ with {}'.format(eachline))
    elif eachline.startswith('#x '): # no echo
      pass
    elif eachline.startswith('# '): # normal comment
      newCommand['comments'].append(eachline)
    elif eachline.startswith('#mls'): # start of multi line
      multilineState = True
    elif eachline.startswith('#mle'): # end of multi line
      multilineState = False
      newCommand['command'] = '\n'.join(multilineList)
      newCommand['line'] = lineNumber
      newCommand['multiline'] = True
      currentCommands.append(newCommand)
      newCommand = None
  else: # this is a command
    if multilineState:
      multilineList.append(eachline)
    else:
      newCommand['command'] = eachline
      newCommand['line'] = lineNumber
      currentCommands.append(newCommand)
      newCommand = None
if len(stack) != 1:
  raise Exception('final stack length should be 1, need debug!')

# add label, stepCount for struct, tune the format
commandCount = 0
labelMaxLength = 1
maxLineNumber = lineNumber
def getFormat(N):
  power = 1
  while N > 10:
    power += 1
    N /= 10.
  return '{{:0{}d}}'.format(power)
def getDigital(N):
  power = 1
  while N > 10:
    power += 1
    N /= 10.
  return power
def modifyStructLabel(s, prefix):
  global commandCount, labelMaxLength
  if len(prefix) > labelMaxLength:
    labelMaxLength = len(prefix)
  s['label'] = prefix
  if s['type'] == 'struct':
    nformat = getFormat(len(s['commands']))
    for index, each in enumerate(s['commands'], start=1):
      index = nformat.format(index)
      if prefix:
        modifyStructLabel(each, f"{prefix}.{index}")
      else:
        modifyStructLabel(each, f"{index}")
  elif s['type'] == 'group':
    commandCount += 1
    s['stepCount'] = commandCount
modifyStructLabel(struct, '')
stepFormat = getFormat(commandCount)
labelFormat = "{{:{}}}".format(labelMaxLength)
lineFormat = getFormat(maxLineNumber)
def modifyStructLength(s):
  s['label'] = labelFormat.format(s['label'])
  s['line'] = lineFormat.format(s['line'])
  if s['type'] == 'struct':
    for each in s['commands']:
      modifyStructLength(each)
  elif s['type'] == 'group':
    s['stepCount'] = stepFormat.format(s['stepCount'])
modifyStructLength(struct)

# output functions
bashTemplate='''#!/bin/bash
RERUN=""
BYSTEP=""
SHOW=""
SHOWCOMMAND=""

if [[ -f '.stepScript.session' ]]; then
  LASTSESSION=`tail -n1 .stepScript.session`
  LASTLINE=$(echo $LASTSESSION | cut -f1 -d"|")
  LASTLABEL=$(echo $LASTSESSION | cut -f2 -d"|")
  LASTCOUNT=$(echo $LASTSESSION | cut -f3 -d"|")
else
  LASTLINE=""
  LASTLABEL=""
  LASTCOUNT=""
fi

CURRENT_LINE=""
CURRENT_LABEL=""
CURRENT_COUNT=""

while getopts 'rsSAl:c:L:' OPT; do
  case $OPT in
    l)
      if [[ -n "$OPTARG" ]]; then
        LASTLABEL="$OPTARG"
      fi
      LASTCOUNT=""
      LASTLINE=""
      ;;
    L)
      if [[ -n "$OPTARG" ]]; then
        LASTLINE="$OPTARG"
      fi
      LASTCOUNT=""
      LASTLABEL=""
      ;;
    c)
      if [[ -n "$OPTARG" ]]; then
        COUNT="$OPTARG"
      fi
      LASTLINE=""
      LASTLABEL=""
      ;;
    r)
      RERUN="True";;
    s)
      BYSTEP="True";;
    S)
      SHOW="True";;
    A)
      SHOWCOMMAND="True";;
    ?)
cat << EOF
usage: $0 [-slcr]
  -r: rerun from the beginning
  -s: run by steps
  -l label: run from label
  -c count: run from code count
  -S: show skipped structures
  -A: show skipped commands
EOF
exit 1
  esac
done

if [[ -z "$RERUN" ]]; then
  if [[ -n "$LASTLABEL" || -n "$LASTCOUNT" ]]; then
    echo "\x1b[36mStart at line:$LASTLINE label:$LASTLABEL count:$LASTCOUNT\x1b[0m"
  fi
fi

check_error () {
  if [[ "$?" -ne 0 ]]; then
    echo "$1"
    exit "$?"
  fi
}
save_state () {
  echo "$1" >> .stepScript.session
}

'''
functionStructTemplate='''f_{label} () {{
CURRENT_LABEL="{label}"
CURRENT_LINE="{line}"
if [[ -z "$RERUN" ]]; then
  if [[ -n "$LASTCOUNT" && "$LASTCOUNT" > "$CURRENT_COUNT" ]]; then
    if [[ -n "$SHOW" ]]; then
      echo "{message}"
    fi
    return
  fi
  if [[ -n "$LASTLINE" && "$LASTLINE" > "$CURRENT_LINE" ]]; then
    if [[ -n "$SHOW" ]]; then
      echo "{message}"
    fi
    return
  fi
  if [[ -n "$LASTLABEL" && "$LASTLABEL" > "$CURRENT_LABEL" ]]; then
    if [[ -n "$SHOW" ]]; then
      echo "{message}"
    fi
    return
  fi
fi
  save_state "{stateMessage}"
  echo "{message}"
}}
'''
functionCommandTemplate='''f_{label} () {{
CURRENT_LABEL="{label}"
CURRENT_COUNT="{count}"
CURRENT_LINE="{line}"
if [[ -z "$RERUN" ]]; then
  if [[ -n "$LASTCOUNT" && "$LASTCOUNT" > "$CURRENT_COUNT" ]]; then
    if [[ -n "$SHOWCOMMAND" ]]; then
      echo "{message}"
    fi
    return
  fi
  if [[ -n "$LASTLINE" && "$LASTLINE" > "$CURRENT_LINE" ]]; then
    if [[ -n "$SHOWCOMMAND" ]]; then
      echo "{message}"
    fi
    return
  fi
  if [[ -n "$LASTLABEL" && "$LASTLABEL" > "$CURRENT_LABEL" ]]; then
    if [[ -n "$SHOWCOMMAND" ]]; then
      echo "{message}"
    fi
    return
  fi
fi
save_state "{stateMessage}"
if [[ -n "$BYSTEP" ]]; then
  printf "{message}"
  read -r _temp
else
  echo "{message}"
fi
{command}
check_error "{errorMessage}"
}}
'''
functionList = []
mainList = []
def gen(s, output=None):
  isRoot = False
  if output is None:
    isRoot = True
    output = {
      'show': [],
      'outfile': ''
    }
  levelStr = '  ' * s['level']
  label = s['label']
  line = s['line']
  if s['type'] == 'struct': # do struct
    prefix = "{line}|{label}|{count}".format(
                line=s['line'],
                label=s['label'],
                count=' ' * getDigital(commandCount))
    if s['level'] >= 0:
      colorLevel = s['level'] if s['level'] < len(levelColor) else len(levelColor)
      title = levelColor[colorLevel].format(f"## {s['title']}")
      stateMessage = f"{prefix}|{levelStr}{title}"
      simpleMessage = f"  {levelStr}{title}"
      output['show'].append(stateMessage)
      functionList.append(functionStructTemplate.format(
        label=label,
        line=line,
        stateMessage=stateMessage,
        message=simpleMessage
      ))
      mainList.append(f'f_{label}')
    for each in s['commands']:
      gen(each, output)
  elif s['type'] == 'group': # do command
    prefix = "{line}|{label}|{count}".format(
                line=s['line'],
                label=s['label'],
                count=s['stepCount'])
    lp = len(prefix)
    blank = " " * lp
    fullMessage = []
    for comment in s['comments']:
      comment = commentStyle.format(comment)
      output['show'].append(f"{blank}|{levelStr}{comment}")
      fullMessage.append(f"  {levelStr}{comment}")
    if s['command']:
      if s.get('multiline'):
        for index, command in enumerate(s['command'].split('\n')):
          if not index:
            stateMessage = f"{prefix}|{levelStr}{command}"
            output['show'].append(stateMessage)
            fullMessage.append(commandStyle.format(f"$ {levelStr}{command}"))
          else:
            output['show'].append(f"{blank}|{levelStr}{command}")
            fullMessage.append(commandStyle.format(f"$ {levelStr}{command}"))
      else:
        stateMessage = f"{prefix}|{levelStr}{s['command']}"
        output['show'].append(stateMessage)
        fullMessage.append(commandStyle.format(f"$ {levelStr}{s['command']}"))
      functionList.append(functionCommandTemplate.format(
        label=label,
        count=s['stepCount'],
        line=line,
        stateMessage=stateMessage,
        message='\n'.join(fullMessage),
        command=s['command'],
        errorMessage=f"{Fore.RED}{stateMessage}{Style.BRIGHT}{Style.RESET_ALL}"
      ))
      mainList.append(f'f_{label}')
  if isRoot:
    output['func'] = functionList
    output['main'] = mainList
    output['outfile'] = '''{bashTemplate}
{func}

{main}
    '''.format(
        bashTemplate=bashTemplate,
        func='\n'.join(functionList),
        main='\n'.join(mainList)
    )
    return output

output = gen(struct)
if onlyShow:
  print('\n'.join(output['show']))
else:
  with open(f'.{inputFile}.step.sh', 'w') as f:
    f.write(output['outfile'])

if debug:
  import ipdb
  ipdb.set_trace()
